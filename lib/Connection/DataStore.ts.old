import Log from '../Log';
import Connection from '../Connection';

type CacheQueueItem = {
    resolve: Function,
    reject: Function
};

class Cache {
    data: {};
    expire: number;
    queue: CacheQueueItem[];
    fetching?: boolean;

    constructor() {
        this.data = {};
        this.expire = 0;
        this.queue = [];
    }

    length(): number {
        return this.queue.length;
    }
}
class ItemCache extends Cache {

};

class ListCache extends Cache {
    key: string|number;

    constructor(key: string|number) {
        super();
        this.key = key;
    }
};

enum ListCacheKeys {
    clientlist = "clid",
    channellist = "cid"
};

const CACHE_EXPIRE: {[cacheName:string]: number} = {
    clientlist: 30000,
    clientinfo: 30000,
    channellist: 30000,
    channelinfo: 30000
};

export default class DataStore {
    connection: Connection;
    store: {
        [listName: string]: {
            [cacheId: string] : Cache
        }
    };
    storeList: Map<string, Cache>;

    constructor(connection: Connection) {
        this.connection = connection;
        this.store = {};
        this.storeList = new Map();
    }

    getCacheTime(cache: Cache, default_expire: number, noCache: boolean): number {
        if (!cache.expire) {
            return 0;
        }
        let cacheAge = cache.expire;
        if (noCache) {
            cacheAge -= default_expire + 1000;
        }
        return cacheAge;
    }

    shouldUpdateCache(cache: Cache, default_expire: number, noCache: boolean) {
        return !cache.data || this.getCacheTime(cache, default_expire, noCache) < Date.now();
    }

    pushToCacheQueue(cache: Cache, item: CacheQueueItem) {
        cache.queue.push(item);
    }

    async request(cache: Cache, list: string, params: SendParamArgs) {
        const data = await this.connection.send(list, params, {
            expectData: true
        }, 1) || {};

        if (cache instanceof ListCache && Array.isArray(data)) {
            // Flatten array to object where ListCache.key is key
            cache.data = data;
        } else if (cache instanceof ItemCache && !Array.isArray(data)) {
            cache.data = data;
        } else {
            throw new Error(`Response does not match cache type. response: ${typeof data} (array: ${Array.isArray(data)})`);
        }

        cache.expire = Date.now() + CACHE_EXPIRE[list];
        if (cache.queue && cache.queue.length) {
            let item: CacheQueueItem | undefined;
            while (item = cache.queue.shift()) {
                item.resolve(data);
            }
        } else {
            Log("Cache queue appears to be empty...", this.constructor.name, 3);
        }
    }

    rejectRequest(err: string, cache: Cache) {
        if (cache.queue && cache.queue.length) {
            let item: CacheQueueItem | undefined;
            while (item = cache.queue.shift()) {
                item.reject(err);
            }
        } else {
            Log(`Request rejected: ${err}, Cache queue appears to be empty...`, this.constructor.name, 3);
        }
    }

    async handleFetch(cache: Cache, list: string, params: SendParamArgs, resolve: Function, reject: Function) {
        this.pushToCacheQueue(cache, {
            resolve,
            reject
        });
        if (!cache.fetching) {
            cache.fetching = true;
            try {
                await this.request(cache, list, params);
            } catch (err) {
                this.rejectRequest(err, cache);
            }
            cache.fetching = false;
        }
    }

    fetchList(list: string, noCache = false): Promise<any[]> {
        let cache = this.storeList.get(list);
        if (!cache) {
            cache = new ListCache(ListCacheKeys[list]);
            this.storeList.set(list, cache);
        }

        return this.fetchPromise(cache, list, noCache);
    }

    fetchItem(list: string, keyName: string, keyValue: string | number, noCache = false): Promise<any> {
        if (!this.store[list]) {
            this.store[list] = {};
        }
        if (!this.store[list][keyValue]) {
            this.store[list][keyValue] = new ItemCache();
        }
        const cache = this.store[list][keyValue];
        return this.fetchPromise(cache, list, noCache, {
            [keyName]: keyValue
        });
    }

    fetchPromise(cache: Cache, list: string, noCache: boolean, params = {}): Promise<any> {
        return new Promise((resolve, reject) => {
            if (this.shouldUpdateCache(cache, CACHE_EXPIRE[list], noCache)) {
                Log(`Fetching resource ${list} ${Object.entries(params)}`, this.constructor.name, 4);
                this.handleFetch(cache, list, params, resolve, reject);
            } else {
                Log(`Using cache (update in ${Math.ceil( (cache.expire - Date.now()) / 1000 ) }s) for resource: ${list} ${Object.entries(params)}`, this.constructor.name, 4);
                resolve(cache.data);
            }
        });
    }

    forceInfoUpdate(list: string, id: string | number, args: object) {
        if (this.store[list] && this.store[list][id]) {
            this.store[list][id].data = {
                ...this.store[list][id].data,
                ...args
            };
        }
    }
    forceListUpdate(list: string, key: string, id: string | number, args: object) {
        const cache = this.storeList.get(list);
        // if (cache) {
        //     for (let i = 0, len = cache.length(); i < len; i++) {
        //         if (cache[i][key] === id) {
        //             cache[i][key].data = {
        //                 ...cache[i][id].data,
        //                 ...args
        //             };
        //             break;
        //         }
        //     }
        // }
    }
}
